"use strict";

// not used as variable, but we include code here:
var async = require('async');
var fs = require('fs');
var cheerio = require('cheerio');
var mockery = require('mockery');

/* removes _properties from definitions because we don't want to check them for compatibility */
var filterProps = function(obj) {
	if (Array.isArray(obj)) {
		for (var i = 0; i < obj.length; i++) filterProps(obj[i]);
	} else if (typeof obj == 'object' && obj !== null) {
		for (var p in obj) if (obj.hasOwnProperty(p)) {
			if (p.startsWith('_') && typeof obj[p] !== 'object') {
				delete obj[p];
			} else filterProps(obj[p]);
		}
	}
}

var checkTemplateDefs = function (templateFile, modelPrefix, testRun) {
	mockery.enable();
	// 'knockout', 'console', 'mensch', 'jsep', './cheerio', './parser.js', '../src/js/converter/main.js', './utils.js', './domutils.js', './editor.js', './declarations.js', './model.js', './stylesheet.js'
	mockery.registerAllowables(['mosaico/src/js/converter/main.js', './model.js', './domutils.js', 'console', './cheerio', './editor.js', './parser.js', './checkmodel.js', './declarations.js', './utils.js']);
	var currentDocument;
	mockery.registerMock('jquery', function () {
		return currentDocument.apply(currentDocument, arguments);
	});

	var templateConverter = require('mosaico/src/js/converter/main.js');

	var outModelFile = modelPrefix+'.model.json';
	var outBlockDefsFile = modelPrefix+'.blocks.json';
	var outDefFile = modelPrefix+'.def.json';
	var outTemplates = modelPrefix+'.tmpl';

	var createOutput = false;
	if (fs.existsSync(outModelFile) && fs.existsSync(outDefFile)) {
		// COMPARE IF OUTDATED or "FORCE"
		var modelChanged = fs.statSync(outModelFile).mtime.getTime();
		var defChanged = fs.statSync(outDefFile).mtime.getTime();
		var templateChanged = fs.statSync(templateFile).mtime.getTime();
		var changed = Math.min(modelChanged, defChanged) < templateChanged;
		if (!changed) {
			console.log("## Ignoring unchanged template ", templateFile);
			return false;
		}
	} else {
		createOutput = true;
	}


	var templatecode = '';
	var joinUrl = function (base, url) {
		if (typeof url !== "undefined") {
			return base + url;
		} else return base;
	};

	var templates = '';
	var myTemplateCreator = function (htmlOrElement, optionalName, templateMode) {
		var name = 'msc-tmpl-' + (typeof optionalName !== 'undefined' ? optionalName : 'anonymous') + '-' + templateMode + '-' + templates.length;
		templates += "\r\n\r\n<!-- ################### " + name + " #################### -->\r\n";
		if (typeof htmlOrElement == 'string') {
			templates += htmlOrElement;
		} else {
			templates += currentDocument('<div></div>').append(htmlOrElement).html();
		}
		return name;
	};
	var editorsTemplateCreator = function (htmlOrElement, optionalName, templateMode) {
		return "Ignoring...";
	};

	try {

		templatecode = "" + fs.readFileSync(templateFile);

		var res = templatecode.match(/^([\S\s]*)([<]html[^>]*>[\S\s]*<\/html>)([\S\s]*)$/i);
		if (res === null) throw "Unable to find <html> opening and closing tags in the template";
		var prefix = res[1];
		var html = res[2].replace(/(<\/?)(html|head|body)([^>]*>)/gi, function (match, p1, p2, p3) { return p1 + 'replaced' + p2 + p3; });
		var postfix = res[3];

		currentDocument = cheerio.load('<body></body>');

		// var res = templateLoader.compile(basePath, 'template', templatecode, undefined, undefined, undefined);
		var templateDef = templateConverter.translateTemplate('template', html, joinUrl, myTemplateCreator);
		var model = templateConverter.generateResultModel(templateDef);
		var baseThreshold = 'myBaseThreshold';
		var widgets = {};
		var blockDefs = templateConverter.generateEditors(templateDef, widgets, joinUrl, editorsTemplateCreator, baseThreshold);

		if (createOutput) {
			if (!testRun) {
				// FIRST TIME CREATE
				console.log("## Creating first time compiled artifacts for template " + templateFile);
				fs.writeFileSync(outModelFile, JSON.stringify(model, ' ', 2));
				fs.writeFileSync(outBlockDefsFile, JSON.stringify(blockDefs, ' ', 2));
				fs.writeFileSync(outDefFile, JSON.stringify(templateDef, ' ', 2));
				fs.writeFileSync(outTemplates, templates);
				console.log("## Done with " + templateFile);
			}
		} else {
			console.log("## Checking template compatibility " + templateFile);
			var savedModel = JSON.parse(fs.readFileSync(outModelFile, 'utf8'));
			var validModel = templateConverter.checkModel(model, blockDefs, savedModel);
			if (validModel == 2) {
				console.error("MAJOR: Model generated by template does not equal the saved model for the same template: " + templateFile);
			} else if (validModel == 1) {
				console.error("MINOR: Model generated by template does not equal the saved model for the same template: " + templateFile);
			}
			var savedDef = JSON.parse(fs.readFileSync(outDefFile, 'utf8'));
			filterProps(savedDef);
			filterProps(templateDef);
			var validDef = templateConverter.checkModel(templateDef, undefined, savedDef);
			if (validDef == 2) {
				console.error("MAJOR: TemplateDefinition generated by template does not equal the saved def for the same template: " + templateFile);
			} else if (validDef == 1) {
				console.error("MINOR: TemplateDefinition generated by template does not equal the saved def for the same template: " + templateFile);
			} else {
				console.log("## Done checking template compatibility " + templateFile);
			}
			// return invalid model
			if (validDef > 1 || validModel > 1) return false;
		}
	} catch (e) {
		console.error("Exception while compiling template: " + templateFile, e);
		return false;
	}

	mockery.disable();
	return true;
};

module.exports = checkTemplateDefs;